/**
 * Feature: Creative Service Server Implementation
 * Purpose: Server-side image generation and creative management
 * References:
 *  - Creative Service Contract: lib/services/contracts/creative-service.interface.ts
 *  - Vercel AI SDK v5: https://sdk.vercel.ai/docs
 *  - AI Gateway Image Generation: https://vercel.com/docs/ai-gateway/image-generation
 *  - Supabase: https://supabase.com/docs
 */

import { generateText } from 'ai';
import { getModel } from '@/lib/ai/gateway-provider';
import { createServerClient } from '@/lib/supabase/server';
import type {
  CreativeService,
  GenerateVariationsInput,
  GenerateVariationsResult,
  EditVariationInput,
  EditVariationResult,
  RegenerateVariationInput,
  SelectVariationInput,
  DeleteVariationInput,
} from '../contracts/creative-service.interface';
import type { ServiceResult } from '@/lib/journeys/types/journey-contracts';

/**
 * Creative Service Server Implementation
 * Handles image generation and creative management
 */
class CreativeServiceServer implements CreativeService {
  generateVariations = {
    async execute(input: GenerateVariationsInput): Promise<ServiceResult<GenerateVariationsResult>> {
      try {
        const supabase = await createServerClient();
        
        // Get user for ownership verification
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
          return {
            success: false,
            error: { code: 'unauthorized', message: 'Not authenticated' }
          };
        }

        // Generate image using Gemini 2.5 Flash Image via AI Gateway
        const result = await generateText({
          model: getModel('google/gemini-2.5-flash-image-preview'),
          providerOptions: {
            google: { responseModalities: ['TEXT', 'IMAGE'] },
          },
          prompt: input.prompt || 'Generate a professional advertising image',
        });

        // Extract image files from result
        const imageFiles = result.files?.filter(f => f.mediaType?.startsWith('image/')) || [];
        
        if (imageFiles.length === 0) {
          return {
            success: false,
            error: { code: 'no_images', message: 'No images generated by model' }
          };
        }

        const variations = [];

        // Process each generated image (up to 3 variations)
        for (let i = 0; i < Math.min(imageFiles.length, 3); i++) {
          const file = imageFiles[i];
          const extension = file.mediaType?.split('/')[1] || 'png';
          const fileName = `creative-${input.adId}-${Date.now()}-${i}.${extension}`;
          
          // Upload to Supabase storage
          const { data: upload, error: uploadError } = await supabase.storage
            .from('ad-creatives')
            .upload(fileName, file.uint8Array, {
              contentType: file.mediaType,
              upsert: false,
            });

          if (uploadError) {
            console.error('[CreativeService] Upload error:', uploadError);
            continue;
          }

          // Get public URL
          const { data: { publicUrl } } = supabase.storage
            .from('ad-creatives')
            .getPublicUrl(fileName);

          // Insert to ad_creatives table
          const { data: creative, error: dbError } = await supabase
            .from('ad_creatives')
            .insert({
              ad_id: input.adId,
              creative_format: 'image',
              image_url: publicUrl,
              sort_order: i,
              creative_style: input.style || null,
              variation_label: String.fromCharCode(65 + i), // A, B, C
            })
            .select()
            .single();

          if (!dbError && creative) {
            variations.push(creative);
          }
        }

        if (variations.length === 0) {
          return {
            success: false,
            error: { code: 'upload_failed', message: 'Failed to upload generated images' }
          };
        }

        return {
          success: true,
          data: {
            variations,
            baseImageUrl: variations[0]?.image_url,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'generation_failed',
            message: error instanceof Error ? error.message : 'Image generation failed',
          },
        };
      }
    },
  };

  editVariation = {
    async execute(input: EditVariationInput): Promise<ServiceResult<EditVariationResult>> {
      try {
        const supabase = await createServerClient();
        
        // Get user
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
          return {
            success: false,
            error: { code: 'unauthorized', message: 'Not authenticated' }
          };
        }

        // Fetch original image
        const imageResponse = await fetch(input.originalImageUrl);
        const imageBuffer = await imageResponse.arrayBuffer();
        const imageUint8Array = new Uint8Array(imageBuffer);

        // Edit image using Gemini with image input
        const result = await generateText({
          model: getModel('google/gemini-2.5-flash-image-preview'),
          providerOptions: {
            google: { responseModalities: ['TEXT', 'IMAGE'] },
          },
          messages: [
            {
              role: 'user',
              content: [
                { type: 'text', text: input.editPrompt || 'Edit this image based on requirements' },
                {
                  type: 'file',
                  mediaType: 'image/png',
                  data: imageUint8Array,
                },
              ],
            },
          ],
        });

        const imageFiles = result.files?.filter(f => f.mediaType?.startsWith('image/')) || [];
        
        if (imageFiles.length === 0) {
          return {
            success: false,
            error: { code: 'no_images', message: 'No edited image generated' }
          };
        }

        const file = imageFiles[0];
        const extension = file.mediaType?.split('/')[1] || 'png';
        const fileName = `creative-edited-${input.adId}-${Date.now()}.${extension}`;
        
        // Upload to Supabase storage
        const { data: upload, error: uploadError } = await supabase.storage
          .from('ad-creatives')
          .upload(fileName, file.uint8Array, {
            contentType: file.mediaType,
            upsert: false,
          });

        if (uploadError) {
          return {
            success: false,
            error: { code: 'upload_failed', message: uploadError.message }
          };
        }

        const { data: { publicUrl } } = supabase.storage
          .from('ad-creatives')
          .getPublicUrl(fileName);

        return {
          success: true,
          data: {
            imageUrl: publicUrl,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'edit_failed',
            message: error instanceof Error ? error.message : 'Image edit failed',
          },
        };
      }
    },
  };

  regenerateVariation = {
    async execute(input: RegenerateVariationInput): Promise<ServiceResult<EditVariationResult>> {
      try {
        const supabase = await createServerClient();
        
        // Get user
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
          return {
            success: false,
            error: { code: 'unauthorized', message: 'Not authenticated' }
          };
        }

        // Generate new image using Gemini (similar to generateVariations but single)
        const result = await generateText({
          model: getModel('google/gemini-2.5-flash-image-preview'),
          providerOptions: {
            google: { responseModalities: ['TEXT', 'IMAGE'] },
          },
          prompt: input.prompt || 'Regenerate professional advertising image',
        });

        const imageFiles = result.files?.filter(f => f.mediaType?.startsWith('image/')) || [];
        
        if (imageFiles.length === 0) {
          return {
            success: false,
            error: { code: 'no_images', message: 'No image generated' }
          };
        }

        const file = imageFiles[0];
        const extension = file.mediaType?.split('/')[1] || 'png';
        const fileName = `creative-regen-${input.adId}-${Date.now()}.${extension}`;
        
        // Upload to Supabase storage
        const { data: upload, error: uploadError } = await supabase.storage
          .from('ad-creatives')
          .upload(fileName, file.uint8Array, {
            contentType: file.mediaType,
            upsert: false,
          });

        if (uploadError) {
          return {
            success: false,
            error: { code: 'upload_failed', message: uploadError.message }
          };
        }

        const { data: { publicUrl } } = supabase.storage
          .from('ad-creatives')
          .getPublicUrl(fileName);

        return {
          success: true,
          data: {
            imageUrl: publicUrl,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'regeneration_failed',
            message: error instanceof Error ? error.message : 'Image regeneration failed',
          },
        };
      }
    },
  };

  selectVariation = {
    async execute(input: SelectVariationInput): Promise<ServiceResult<void>> {
      try {
        const supabase = await createServerClient();
        
        // Update selected_creative_id on ads table
        const { error } = await supabase
          .from('ads')
          .update({ selected_creative_id: input.variationIndex.toString() })
          .eq('id', input.adId);

        if (error) {
          return {
            success: false,
            error: {
              code: 'update_failed',
              message: error.message,
            },
          };
        }

        return { success: true };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'internal_error',
            message: error instanceof Error ? error.message : 'Unknown error',
          },
        };
      }
    },
  };

  deleteVariation = {
    async execute(input: DeleteVariationInput): Promise<ServiceResult<void>> {
      try {
        const supabase = await createServerClient();
        
        // Get current user for ownership verification
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
          return {
            success: false,
            error: {
              code: 'unauthorized',
              message: 'Not authenticated',
            },
          };
        }

        // Delete creative with ownership verification via ad â†’ campaign (RLS enforced)
        const { error } = await supabase
          .from('ad_creatives')
          .delete()
          .eq('id', input.creativeId)
          .eq('ad_id', input.adId);

        if (error) {
          return {
            success: false,
            error: {
              code: 'deletion_failed',
              message: error.message,
            },
          };
        }

        return {
          success: true,
          data: undefined,
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'internal_error',
            message: error instanceof Error ? error.message : 'Failed to delete variation',
          },
        };
      }
    },
  };
}

// Export singleton instance
export const creativeServiceServer = new CreativeServiceServer();

