# AdPilot - Master Project Architecture

**Version:** v1.0  
**Last Updated:** November 15, 2025  
**Status:** ‚úÖ Production Architecture  

> **This is the definitive architecture reference for the AdPilot project.**  
> Covers complete system architecture: API v1, Supabase backend, and client integration.

---

## Table of Contents

1. [System Overview](#1-system-overview)
2. [Before & After Architecture](#2-before--after-architecture)
3. [API v1 Architecture](#3-api-v1-architecture)
4. [Database Architecture](#4-database-architecture)
5. [Request Flow Architecture](#5-request-flow-architecture)
6. [Type System Architecture](#6-type-system-architecture)
7. [Security Architecture](#7-security-architecture)
8. [Client Integration Architecture](#8-client-integration-architecture)
9. [Data Flow Examples](#9-data-flow-examples)
10. [Performance Architecture](#10-performance-architecture)
11. [Migration Strategy](#11-migration-strategy)
12. [Technology Stack](#12-technology-stack)
13. [Location Targeting Architecture](#13-location-targeting-architecture)

---

# 1. System Overview

## What Is AdPilot?

AdPilot is a SaaS platform for creating and managing Meta (Facebook/Instagram) advertising campaigns using AI-powered creative generation and conversation-based workflows.

### Core Features
- **AI-Driven Campaign Creation:** Conversational interface for building ads
- **Meta Integration:** Direct publishing to Facebook/Instagram via Meta Marketing API
- **Creative Generation:** AI-powered image and copy generation
- **Lead Management:** Capture and export leads from Meta Lead Gen campaigns
- **Analytics:** Real-time metrics and demographic breakdowns

### Technology Stack

```mermaid
graph TB
    subgraph "Frontend"
        Next[Next.js 15]
        React[React 18]
        TQ[TanStack Query]
        UI[shadcn/ui]
    end
    
    subgraph "Backend"
        V1API[API v1<br/>26 Routes]
        MW[Middleware<br/>Auth, Errors]
        Types[Type System]
    end
    
    subgraph "Infrastructure"
        SB[(Supabase<br/>PostgreSQL)]
        Meta[Meta Marketing API]
        AISDK[Vercel AI SDK v5]
        Images[Image Generation<br/>OpenAI DALL-E]
    end
    
    Next --> V1API
    React --> TQ
    TQ --> V1API
    V1API --> MW
    MW --> Types
    V1API --> SB
    V1API --> Meta
    V1API --> AISDK
    AISDK --> Images
    
    style Next fill:#0070f3,color:#fff
    style V1API fill:#10b981,color:#fff
    style SB fill:#3ecf8e,color:#000
    style Meta fill:#1877f2,color:#fff
```

### Architecture Goals

| Goal | How Achieved |
|---|---|
| **Performance** | 12 database indexes, query optimization, caching |
| **Type Safety** | TypeScript strict mode, zero `any` types, type guards |
| **Security** | Multi-layer: API auth + RLS policies + type validation |
| **Scalability** | Flat API structure, resource-based design |
| **Maintainability** | Shared middleware, standardized patterns |
| **Real-time** | Supabase subscriptions for live updates |

---

# 2. Before & After Architecture

## Old Architecture (Pre-v1)

```mermaid
graph TB
    Client[Next.js Client<br/>Components]
    OldAPI[Old API Structure<br/>71 files<br/>4-5 levels deep]
    LS[localStorage<br/>Meta Data]
    JSONB[campaign_states<br/>JSONB Fields]
    Supabase[(Supabase<br/>Database)]
    Meta[Meta API]
    
    Client --> OldAPI
    Client -.-> LS
    OldAPI --> JSONB
    OldAPI --> Supabase
    OldAPI --> Meta
    LS -.-> OldAPI
    
    subgraph "Problems"
        Deep[Deep Nesting<br/>/campaigns/[id]/ads/[adId]/publish]
        Dup[Duplicate Logic<br/>Auth in every file]
        Mixed[Mixed Formats<br/>Inconsistent responses]
        Sync[Data Sync Issues<br/>localStorage vs DB]
    end
    
    style OldAPI fill:#faa,stroke:#333
    style LS fill:#faa,stroke:#333
    style JSONB fill:#ffa,stroke:#333
```

### Old Architecture Issues

| Issue | Description | Impact |
|---|---|---|
| **Deep Nesting** | Routes 4-5 levels deep | Hard to navigate, complex routing |
| **Duplicate Code** | Auth/ownership in every file | Maintenance burden, inconsistencies |
| **Inconsistent Responses** | No standard format | Client-side complexity |
| **localStorage Dependency** | Meta data in browser | Sync issues, cross-device problems |
| **No Type Safety** | Mixed `any` usage | Runtime errors |
| **No Indexes** | Table scans for queries | Slow performance |
| **Scattered Meta Logic** | 24 different endpoints | Hard to maintain |

## New v1 Architecture

```mermaid
graph TB
    Client[Next.js Client<br/>Components]
    Hooks[React Query Hooks<br/>useAds, useCampaigns]
    APIClient[API Client Library<br/>lib/api/client.ts]
    V1API[v1 API<br/>26 routes<br/>max 2 levels]
    MW[Shared Middleware<br/>Auth, Errors, Rate Limit]
    Types[Type System<br/>lib/types/api.ts]
    CMC[(campaign_meta_connections<br/>Single Source of Truth)]
    Supabase[(Supabase<br/>10 Tables + 12 Indexes)]
    Meta[Meta API]
    AISDK[Vercel AI SDK v5<br/>AI Gateway]
    
    Client --> Hooks
    Hooks --> APIClient
    APIClient --> V1API
    V1API --> MW
    MW --> Types
    V1API --> CMC
    V1API --> Supabase
    V1API --> Meta
    V1API --> AISDK
    CMC --> Supabase
    
    subgraph "Improvements"
        Flat[Flat Structure<br/>/ads/[id]/publish]
        Shared[Shared Logic<br/>Middleware]
        Std[Standardized<br/>success, data, error]
        SST[Single Source<br/>campaign_meta_connections]
    end
    
    style V1API fill:#afa,stroke:#333
    style MW fill:#afa,stroke:#333
    style CMC fill:#3ecf8e,stroke:#333
    style Supabase fill:#3ecf8e,stroke:#333
```

### v1 Architecture Improvements

| Improvement | Before | After | Benefit |
|---|---|---|---|
| **File Count** | 71 API files | 26 API routes | 63% reduction, easier to navigate |
| **Nesting** | 4-5 levels | Max 2 levels | Simpler routing, clearer ownership |
| **Auth Logic** | Repeated in each file | Shared middleware | Single source, consistency |
| **Responses** | Inconsistent | `{success, data, error}` | Predictable client handling |
| **Meta Data** | localStorage | `campaign_meta_connections` table | No sync issues, realtime works |
| **Type Safety** | Mixed `any` | Zero `any`, type guards | Compile-time safety |
| **Performance** | Table scans | 12 indexes | 10x faster queries |
| **Error Handling** | Ad-hoc | 23 error codes | Structured client handling |

---

# 3. API v1 Architecture

## Resource-Based Structure

```mermaid
graph LR
    V1[/api/v1/]
    
    V1 --> Campaigns[campaigns/]
    V1 --> Ads[ads/]
    V1 --> Meta[meta/]
    V1 --> Leads[leads/]
    V1 --> Chat[chat/]
    V1 --> Conv[conversations/]
    V1 --> Images[images/]
    V1 --> Creative[creative/]
    
    Campaigns --> C1[route.ts<br/>GET list, POST create]
    Campaigns --> C2["[id]/route.ts<br/>GET, PATCH, DELETE"]
    Campaigns --> C3["[id]/state/route.ts<br/>GET, PATCH state"]
    
    Ads --> A1[route.ts<br/>GET ?campaignId, POST]
    Ads --> A2["[id]/route.ts<br/>GET, PATCH, DELETE"]
    Ads --> A3["[id]/publish/<br/>POST to Meta"]
    Ads --> A4["[id]/pause/<br/>POST pause"]
    Ads --> A5["[id]/resume/<br/>POST resume"]
    Ads --> A6["[id]/save/<br/>GET/POST snapshot"]
    
    Meta --> M1[status/<br/>GET connection]
    Meta --> M2[assets/<br/>GET biz/pages/accounts]
    Meta --> M3[payment/<br/>GET/POST payment]
    Meta --> M4[admin/<br/>GET/POST admin]
    Meta --> M5[metrics/<br/>GET with refresh]
    Meta --> M6[breakdown/<br/>GET age/gender]
    Meta --> M7[forms/<br/>GET list]
    Meta --> M8["forms/[id]/<br/>GET details"]
    
    Leads --> L1[route.ts<br/>GET paginated list]
    Leads --> L2[export/<br/>GET CSV/JSON]
    
    Chat --> CH1[route.ts<br/>POST streaming]
    
    Conv --> CV1[route.ts<br/>GET list, POST create]
    Conv --> CV2["[id]/route.ts<br/>GET, PATCH"]
    Conv --> CV3["[id]/messages/<br/>GET list, POST add"]
    
    Images --> I1[variations/<br/>POST generate]
    Images --> I2[variations/single/<br/>POST edit]
    
    Creative --> CR1[plan/<br/>POST generate]
    
    style V1 fill:#0070f3,color:#fff
    style Campaigns fill:#10b981,color:#fff
    style Ads fill:#10b981,color:#fff
    style Meta fill:#3b82f6,color:#fff
```

## Complete API Endpoint Table

| Resource | Endpoint | Method | Purpose | Auth | Ownership Check |
|---|---|---|---|---|---|
| **Campaigns** | | | | | |
| | `/api/v1/campaigns` | GET | List user campaigns | ‚úÖ | user_id filter |
| | `/api/v1/campaigns` | POST | Create campaign | ‚úÖ | user_id set |
| | `/api/v1/campaigns/[id]` | GET | Get campaign | ‚úÖ | user_id = auth.uid |
| | `/api/v1/campaigns/[id]` | PATCH | Update campaign | ‚úÖ | user_id = auth.uid |
| | `/api/v1/campaigns/[id]` | DELETE | Delete campaign | ‚úÖ | user_id = auth.uid |
| | `/api/v1/campaigns/[id]/state` | GET | Get wizard state | ‚úÖ | via campaign |
| | `/api/v1/campaigns/[id]/state` | PATCH | Update wizard state | ‚úÖ | via campaign |
| **Ads** | | | | | |
| | `/api/v1/ads` | GET | List ads | ‚úÖ | via campaign |
| | `/api/v1/ads` | POST | Create ad | ‚úÖ | via campaign |
| | `/api/v1/ads/[id]` | GET | Get ad | ‚úÖ | campaigns!inner(user_id) |
| | `/api/v1/ads/[id]` | PATCH | Update ad | ‚úÖ | campaigns!inner(user_id) |
| | `/api/v1/ads/[id]` | DELETE | Delete ad | ‚úÖ | campaigns!inner(user_id) |
| | `/api/v1/ads/[id]/publish` | POST | Publish to Meta | ‚úÖ | campaigns!inner(user_id) |
| | `/api/v1/ads/[id]/pause` | POST | Pause ad | ‚úÖ | campaigns!inner(user_id) |
| | `/api/v1/ads/[id]/resume` | POST | Resume ad | ‚úÖ | campaigns!inner(user_id) |
| | `/api/v1/ads/[id]/save` | POST | Save snapshot | ‚úÖ | campaigns!inner(user_id) |
| | `/api/v1/ads/[id]/save` | GET | Get snapshot | ‚úÖ | campaigns!inner(user_id) |
| **Meta** | | | | | |
| | `/api/v1/meta/status` | GET | Connection status | ‚úÖ | via campaign |
| | `/api/v1/meta/assets` | GET | List assets | ‚úÖ | via campaign |
| | `/api/v1/meta/payment` | GET | Payment status | ‚úÖ | via campaign |
| | `/api/v1/meta/payment` | POST | Mark payment | ‚úÖ | via campaign |
| | `/api/v1/meta/admin` | GET | Admin status | ‚úÖ | via campaign |
| | `/api/v1/meta/admin` | POST | Verify admin | ‚úÖ | via campaign |
| | `/api/v1/meta/metrics` | GET | Get metrics | ‚úÖ | via campaign |
| | `/api/v1/meta/breakdown` | GET | Demographic data | ‚úÖ | via campaign |
| | `/api/v1/meta/forms` | GET | List forms | ‚úÖ | via campaign |
| | `/api/v1/meta/forms/[id]` | GET | Form details | ‚úÖ | via campaign |
| **Leads** | | | | | |
| | `/api/v1/leads` | GET | List leads | ‚úÖ | via campaign |
| | `/api/v1/leads/export` | GET | Export CSV/JSON | ‚úÖ | via campaign |
| **Chat** | | | | | |
| | `/api/v1/chat` | POST | AI streaming chat | ‚úÖ | via campaign |
| **Conversations** | | | | | |
| | `/api/v1/conversations` | GET | List conversations | ‚úÖ | user_id filter |
| | `/api/v1/conversations` | POST | Create conversation | ‚úÖ | user_id set |
| | `/api/v1/conversations/[id]` | GET | Get conversation | ‚úÖ | user_id = auth.uid |
| | `/api/v1/conversations/[id]` | PATCH | Update conversation | ‚úÖ | user_id = auth.uid |
| | `/api/v1/conversations/[id]/messages` | GET | List messages | ‚úÖ | via conversation |
| | `/api/v1/conversations/[id]/messages` | POST | Add message | ‚úÖ | via conversation |
| **Images** | | | | | |
| | `/api/v1/images/variations` | POST | Generate variations | ‚ö†Ô∏è | Client-side tool |
| | `/api/v1/images/variations/single` | POST | Edit single image | ‚ö†Ô∏è | Client-side tool |
| **Creative** | | | | | |
| | `/api/v1/creative/plan` | POST | Generate plan | ‚úÖ | via campaign |

**Total:** 40 HTTP methods across 26 routes

---

# 4. Database Architecture

## Entity Relationship Diagram

```mermaid
erDiagram
    CAMPAIGNS ||--o{ CAMPAIGN_STATES : has
    CAMPAIGNS ||--o{ ADS : contains
    CAMPAIGNS ||--o| CAMPAIGN_META_CONNECTIONS : has
    CAMPAIGNS ||--o{ LEAD_FORM_SUBMISSIONS : receives
    CAMPAIGNS ||--o{ CONVERSATIONS : has
    CAMPAIGNS ||--o{ BUDGET_ALLOCATIONS : has
    
    ADS ||--o| AD_PUBLISHING_METADATA : has
    ADS ||--o{ AD_STATUS_TRANSITIONS : logs
    ADS ||--o{ BUDGET_ALLOCATIONS : has
    
    CONVERSATIONS ||--o{ MESSAGES : contains
    
    CAMPAIGNS {
        uuid id PK
        uuid user_id FK "auth.users"
        text name UK "unique per user"
        text status "draft,active,paused,completed"
        int current_step "1-6"
        jsonb metadata
        text initial_goal "leads,calls"
        timestamp created_at
        timestamp updated_at
    }
    
    CAMPAIGN_STATES {
        uuid id PK
        uuid campaign_id FK UK
        jsonb goal_data "selected goal, form data"
        jsonb location_data "targeting locations"
        jsonb ad_copy_data "copy variations"
        jsonb ad_preview_data "generated ads"
        jsonb budget_data "daily budget, schedule"
        jsonb meta_connect_data "legacy, backward compat"
    }
    
    CAMPAIGN_META_CONNECTIONS {
        uuid id PK
        uuid campaign_id FK UK
        uuid user_id FK
        text fb_user_id
        text long_lived_user_token
        text selected_business_id
        text selected_page_id
        text selected_ad_account_id
        boolean ad_account_payment_connected
        boolean admin_connected
        boolean user_app_connected
        text connection_status
        timestamp connected_at
    }
    
    ADS {
        uuid id PK
        uuid campaign_id FK
        text name
        jsonb creative_data "images, variations"
        jsonb copy_data "headline, body, CTA"
        jsonb setup_snapshot "complete ad config"
        text meta_ad_id "Facebook Ad ID"
        enum status "draft,pending_review,active,paused,etc"
        text destination_type "instant_form,website_url,phone"
        jsonb destination_data
        timestamp created_at
    }
    
    AD_PUBLISHING_METADATA {
        uuid id PK
        uuid ad_id FK UK
        text meta_ad_id
        enum current_status
        enum previous_status
        jsonb status_history "audit trail"
        text error_code
        text error_message
        int retry_count
        timestamp submission_timestamp
    }
    
    AD_STATUS_TRANSITIONS {
        uuid id PK
        uuid ad_id FK
        enum from_status
        enum to_status
        text triggered_by "user,meta_webhook,system"
        jsonb metadata
        timestamp transitioned_at
    }
    
    LEAD_FORM_SUBMISSIONS {
        uuid id PK
        uuid campaign_id FK
        text meta_lead_id UK
        text meta_form_id
        jsonb form_data "dynamic fields"
        timestamp submitted_at
        timestamp exported_at
        boolean webhook_sent
    }
    
    CONVERSATIONS {
        uuid id PK
        uuid campaign_id FK
        uuid user_id FK
        text title
        int message_count
        jsonb metadata
        timestamp created_at
    }
    
    MESSAGES {
        text id PK "AI SDK generated"
        uuid conversation_id FK
        text role "user,assistant,system"
        text content "searchable text"
        jsonb parts "AI SDK v5 parts array"
        jsonb tool_invocations "tool calls"
        bigint seq "monotonic ordering"
        jsonb metadata "editing context"
    }
```

## Database Tables Detail

| Table | Purpose | Key Fields | Indexes | RLS Policies |
|---|---|---|---|---|
| `campaigns` | User campaigns | id, user_id, name, status | 2 (user+updated, status) | 4 (SELECT, INSERT, UPDATE, DELETE) |
| `campaign_states` | Wizard state | campaign_id, goal_data, location_data, ad_preview_data | 1 (JSONB GIN) | 4 |
| `campaign_meta_connections` | Meta connections | campaign_id UK, fb_user_id, selected_ad_account_id | 2 (campaign, user+status) | 8 (duplicate sets) |
| `ads` | Ad creatives | id, campaign_id, meta_ad_id, status, setup_snapshot | 3 (campaign+status, campaign+updated, campaign+created) | 5 (SELECT, INSERT, UPDATE, DELETE, + duplicates) |
| `ad_publishing_metadata` | Publishing tracking | ad_id UK, meta_ad_id, current_status, error_code | 4 (ad_id, meta_ad_id, status, error) | 3 (SELECT, INSERT, UPDATE) |
| `ad_status_transitions` | Status audit trail | ad_id, from_status, to_status, transitioned_at | 1 (ad_id+time) | 1 (SELECT) |
| `meta_webhook_events` | Webhook logs | event_id UK, meta_ad_id, ad_id, payload | 4 (meta_ad, ad, processed, type) | 1 (system all) |
| `lead_form_submissions` | Lead submissions | meta_lead_id UK, campaign_id, form_data JSONB | 3 (campaign+submitted, campaign+created, exported) | 4 (SELECT, INSERT, UPDATE, DELETE) |
| `conversations` | AI chat conversations | id, campaign_id, user_id | 2 (campaign+created, user) | 4 |
| `messages` | Chat messages | id PK, conversation_id, seq, parts JSONB | 1 (conversation+seq) | 4 |

### Database Helper Functions

**Function 1: user_owns_campaign**
```sql
CREATE FUNCTION user_owns_campaign(p_campaign_id UUID, p_user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM campaigns
    WHERE id = p_campaign_id AND user_id = p_user_id
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Function 2: get_meta_connection_status**
```sql
CREATE FUNCTION get_meta_connection_status(p_campaign_id UUID, p_user_id UUID)
RETURNS TABLE (
  ad_account_id TEXT,
  payment_connected BOOLEAN,
  admin_connected BOOLEAN,
  user_app_connected BOOLEAN,
  connection_status TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cmc.selected_ad_account_id,
    cmc.ad_account_payment_connected,
    cmc.admin_connected,
    cmc.user_app_connected,
    cmc.connection_status
  FROM campaign_meta_connections cmc
  JOIN campaigns c ON c.id = cmc.campaign_id
  WHERE cmc.campaign_id = p_campaign_id AND c.user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

# 5. Request Flow Architecture

## Standard Request Flow

```mermaid
sequenceDiagram
    participant C as Client
    participant API as v1 API Route
    participant MW as Middleware
    participant SB as Supabase
    participant Meta as Meta API
    
    C->>API: POST /api/v1/ads/[id]/publish
    Note over API: Parse request
    
    API->>MW: requireAuth(req)
    MW->>SB: auth.getUser()
    SB-->>MW: User object
    MW-->>API: Authenticated User
    
    API->>MW: requireAdOwnership(adId, userId)
    MW->>SB: SELECT ad JOIN campaigns
    SB-->>MW: Ad + Campaign data
    MW->>MW: Verify campaigns.user_id = user.id
    MW-->>API: Ownership confirmed
    
    API->>SB: Get ad details + setup_snapshot
    SB-->>API: Complete ad data
    
    API->>API: validatePrePublish()
    Note over API: Check creative, copy, destination
    
    API->>Meta: POST /{ad_account_id}/campaigns
    Meta-->>API: Campaign ID
    
    API->>Meta: POST /{campaign_id}/adsets
    Meta-->>API: AdSet ID
    
    API->>Meta: POST /{ad_set_id}/ads
    Meta-->>API: Ad ID
    
    API->>SB: UPDATE ads SET meta_ad_id, status='active'
    SB-->>API: Updated ad
    
    SB->>C: Realtime event (status change)
    
    API->>C: { success: true, data: { meta_ad_id } }
    
    Note over C: UI updates automatically<br/>via Supabase realtime
```

## Authentication Flow

```mermaid
graph TD
    Request[Incoming HTTP Request]
    
    Request --> ParseReq[Parse Request<br/>URL, headers, body]
    ParseReq --> Auth[createServerClient]
    Auth --> GetUser[auth.getUser]
    
    GetUser -->|Error or No User| E401[Return 401<br/>Unauthorized]
    GetUser -->|User Found| ExtractID[Extract user.id]
    
    ExtractID --> CheckOwn{Requires<br/>Ownership?}
    
    CheckOwn -->|Campaign Route| QueryCamp[Query campaigns<br/>WHERE id AND user_id]
    CheckOwn -->|Ad Route| QueryAd[Query ads JOIN campaigns<br/>WHERE ad.id]
    CheckOwn -->|No Ownership| Process[Process Request]
    
    QueryCamp -->|Not Found| E404[Return 404<br/>Not Found]
    QueryCamp -->|Found| CheckUID{user_id<br/>matches?}
    
    QueryAd -->|Not Found| E404
    QueryAd -->|Found| CheckAdUID{campaigns.user_id<br/>matches?}
    
    CheckUID -->|No| E403[Return 403<br/>Forbidden]
    CheckUID -->|Yes| RLS{RLS Policy}
    
    CheckAdUID -->|No| E403
    CheckAdUID -->|Yes| RLS
    
    RLS -->|Blocked| E403
    RLS -->|Allowed| Process
    
    Process --> Success[Success Response]
    
    style Auth fill:#3b82f6,color:#fff
    style RLS fill:#10b981,color:#fff
    style E401 fill:#ef4444,color:#fff
    style E403 fill:#ef4444,color:#fff
    style E404 fill:#f59e0b,color:#fff
```

---

# 6. Type System Architecture

## Type Flow

```mermaid
graph LR
    DB[(Supabase<br/>PostgreSQL Schema)]
    Gen[Generated Types<br/>database.types.ts]
    API[API Types<br/>lib/types/api.ts]
    Routes[v1 Route Files]
    Client[Client Code]
    
    DB -->|Supabase CLI| Gen
    Gen -->|Import| API
    API -->|Request Types| Routes
    API -->|Response Types| Routes
    Routes -->|Typed Responses| Client
    
    subgraph "Type Safety Guarantees"
        Guards[Type Guards<br/>isCreateAdRequest]
        Unknown[Unknown ‚Üí Narrow<br/>Runtime validation]
        NoAny[Zero any Types<br/>Compile-time safety]
    end
    
    Routes --> Guards
    Guards --> Unknown
    Unknown --> NoAny
    
    style DB fill:#3ecf8e,color:#000
    style Gen fill:#3b82f6,color:#fff
    style API fill:#8b5cf6,color:#fff
    style NoAny fill:#10b981,color:#fff
```

## Type Hierarchy

```
Database Types (Generated)
  ‚îî‚îÄ> lib/supabase/database.types.ts
        ‚îú‚îÄ> export type Json
        ‚îú‚îÄ> export type Database
        ‚îú‚îÄ> Tables['campaigns']['Row']
        ‚îú‚îÄ> Tables['ads']['Row']
        ‚îî‚îÄ> Enums['ad_status_enum']

API Types (Manual)
  ‚îî‚îÄ> lib/types/api.ts
        ‚îú‚îÄ> ApiResponse<T>
        ‚îú‚îÄ> ApiError
        ‚îú‚îÄ> CreateCampaignRequest
        ‚îú‚îÄ> CreateAdRequest
        ‚îú‚îÄ> MetaConnectionStatus
        ‚îî‚îÄ> ListLeadsResponse

Route Types (Derived)
  ‚îî‚îÄ> app/api/v1/**/route.ts
        ‚îú‚îÄ> Type guards (isCreateAdRequest)
        ‚îú‚îÄ> Request validation
        ‚îî‚îÄ> Response typing
```

---

# 7. Security Architecture

## Multi-Layer Security

```mermaid
graph TD
    Request[Incoming Request]
    
    Request --> L1{Layer 1<br/>Authentication}
    L1 -->|No Auth| E401[401 Unauthorized]
    L1 -->|Authenticated| L2{Layer 2<br/>API Ownership Check}
    
    L2 -->|Campaign Route| CampCheck[SELECT campaigns<br/>WHERE id AND user_id]
    L2 -->|Ad Route| AdCheck[SELECT ads<br/>JOIN campaigns<br/>WHERE ad.id]
    
    CampCheck -->|Not Owner| E403[403 Forbidden]
    CampCheck -->|Owner| L3{Layer 3<br/>RLS Policy}
    
    AdCheck -->|Not Owner| E403
    AdCheck -->|Owner| L3
    
    L3 -->|Policy Denies| E403
    L3 -->|Policy Allows| L4{Layer 4<br/>Type Validation}
    
    L4 -->|Invalid Type| E400[400 Bad Request]
    L4 -->|Valid Type| DB[(Database Query)]
    
    DB -->|Success| Response[Success Response<br/>200/201]
    DB -->|Error| E500[500 Internal Error]
    
    style L1 fill:#f59e0b,color:#000
    style L2 fill:#3b82f6,color:#fff
    style L3 fill:#10b981,color:#fff
    style L4 fill:#8b5cf6,color:#fff
    style E401 fill:#ef4444,color:#fff
    style E403 fill:#ef4444,color:#fff
    style E400 fill:#ef4444,color:#fff
    style E500 fill:#ef4444,color:#fff
```

## Security Layers Detail

| Layer | Mechanism | Enforced By | Purpose |
|---|---|---|---|
| **1. Authentication** | Supabase auth cookie | `createServerClient().auth.getUser()` | Verify user is logged in |
| **2. API Ownership** | Database query with user_id filter | `.eq('user_id', user.id)` or JOIN | Verify resource belongs to user |
| **3. RLS Policies** | PostgreSQL Row Level Security | Database policies on auth.uid() | Defense in depth |
| **4. Type Validation** | TypeScript + type guards | Runtime validation | Prevent bad data |
| **5. SQL Injection Prevention** | Parameterized queries | Supabase client methods | No string concatenation |

## RLS Policy Examples

**Campaigns:**
```sql
-- Users can only SELECT their own campaigns
CREATE POLICY "Users can view own campaigns"
  ON campaigns FOR SELECT
  USING (user_id = auth.uid());
```

**Ads (via relation):**
```sql
-- Users can only SELECT ads from their campaigns
CREATE POLICY "Users can view own ads"
  ON ads FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM campaigns
      WHERE campaigns.id = ads.campaign_id
      AND campaigns.user_id = auth.uid()
    )
  );
```

**Meta Connections:**
```sql
-- Users can only SELECT their own connections
CREATE POLICY "Users can view own campaign connections"
  ON campaign_meta_connections FOR SELECT
  USING (user_id = auth.uid());
```

---

# 8. Client Integration Architecture

## Integration Layers

```mermaid
graph TB
    UI[React Components<br/>dashboard.tsx, ad-card.tsx, etc]
    Hooks[React Query Hooks<br/>useCampaigns, useAds, usePublishAd]
    Client[API Client Library<br/>lib/api/client.ts]
    V1[v1 API Endpoints<br/>26 routes]
    
    UI --> Hooks
    Hooks --> Client
    Client --> V1
    
    subgraph "To Be Created"
        direction TB
        Client
        Hooks
    end
    
    subgraph "Already Built ‚úÖ"
        direction TB
        V1
    end
    
    style UI fill:#0070f3,color:#fff
    style Hooks fill:#fbbf24,color:#000
    style Client fill:#fbbf24,color:#000
    style V1 fill:#10b981,color:#fff
```

## Client Migration Roadmap

| Week | Tasks | Files Affected | Status |
|---|---|---|---|
| **Week 1** | Create API client library | `lib/api/client.ts` | ‚è∏Ô∏è To Do |
| | Create React Query hooks | `lib/hooks/useApiClient.ts` | ‚è∏Ô∏è To Do |
| | Test in development | - | ‚è∏Ô∏è To Do |
| **Week 2** | Update campaign components | 5 files | ‚è∏Ô∏è To Do |
| | Update ad components | 8 files | ‚è∏Ô∏è To Do |
| | Update Meta components | 6 files | ‚è∏Ô∏è To Do |
| | Integration testing | - | ‚è∏Ô∏è To Do |
| **Week 3** | Update leads/analytics | 4 files | ‚è∏Ô∏è To Do |
| | Deploy to staging | - | ‚è∏Ô∏è To Do |
| | Monitor & fix issues | - | ‚è∏Ô∏è To Do |
| **Week 4** | Deploy to production | - | ‚è∏Ô∏è To Do |
| | Remove old routes (40 files) | app/api/* | ‚è∏Ô∏è To Do |
| | Archive migration docs | - | ‚è∏Ô∏è To Do |

## Component Integration Points

| Component | Current API Call | New v1 Call | Migration Complexity |
|---|---|---|---|
| `components/dashboard.tsx` | `/api/campaigns` | `/api/v1/campaigns` | Low - Simple replacement |
| `components/campaign-workspace.tsx` | `/api/campaigns/[id]` | `/api/v1/campaigns/[id]` | Low - Same pattern |
| `components/all-ads-grid.tsx` | `/api/campaigns/[id]/ads` | `/api/v1/ads?campaignId=` | Medium - Query param change |
| `components/ad-card.tsx` | `/api/campaigns/[id]/ads/[adId]/publish` | `/api/v1/ads/[adId]/publish` | Low - Remove campaign from path |
| `components/meta/meta-setup.tsx` | `/api/meta/selection` | `/api/v1/meta/status` | Medium - Response format change |
| `components/meta/payment-setup.tsx` | `/api/meta/payment`, `/api/meta/payment/status` | `/api/v1/meta/payment` (both GET/POST) | Low - Unified endpoint |
| `components/results/leads-table.tsx` | `/api/meta/leads` | `/api/v1/leads` | Low - Same params |
| `components/results/analytics-dashboard.tsx` | `/api/meta/metrics` | `/api/v1/meta/metrics` | Low - Same params |

---

# 9. Data Flow Examples

## Campaign Creation Flow

```mermaid
sequenceDiagram
    participant U as User
    participant UI as Homepage
    participant API as POST /api/v1/campaigns
    participant Name as AI Name Generator
    participant DB as Supabase
    participant Conv as Conversation Service
    
    U->>UI: Submit prompt + goal
    UI->>UI: Save to localStorage<br/>temp_prompt_id
    UI->>UI: Redirect to /auth/post-login
    
    Note over U,UI: User signs up/logs in
    
    UI->>API: POST {tempPromptId, goalType}
    API->>DB: SELECT temp_prompt WHERE id
    DB-->>API: Prompt data
    
    API->>Name: generateCampaignNameAI(prompt, goal)
    Name-->>API: "Pet Care Services Campaign"
    
    API->>DB: INSERT campaigns
    DB-->>API: Campaign created
    
    API->>DB: INSERT campaign_states<br/>(goal_data from temp prompt)
    DB-->>API: State created
    
    API->>Conv: createConversation(userId, campaignId)
    Conv->>DB: INSERT conversation
    DB-->>Conv: Conversation created
    Conv-->>API: Conversation ID
    
    API->>DB: INSERT ads (initial draft)
    DB-->>API: Draft ad created
    
    API->>DB: UPDATE temp_prompts SET used=true
    
    API-->>UI: {success: true, data: {campaign}}
    UI->>U: Redirect to /[campaignId]
```

## Ad Publishing Flow

```mermaid
sequenceDiagram
    participant U as User
    participant UI as Ad Card Component
    participant API as POST /api/v1/ads/[id]/publish
    participant Val as Pre-Publish Validator
    participant DB as Supabase
    participant Meta as Meta Marketing API
    participant RT as Realtime Channel
    
    U->>UI: Click "Publish"
    UI->>UI: Show loading state
    
    UI->>API: POST /api/v1/ads/[adId]/publish
    
    API->>DB: UPDATE ads SET status='pending_review'
    DB-->>API: Status updated
    DB->>RT: Broadcast status change
    RT-->>UI: Realtime event
    UI->>U: Show "Reviewing..." badge
    
    API->>Val: validatePrePublish({campaignId, adId, userId})
    Val->>DB: Check creative_data exists
    Val->>DB: Check copy_data exists
    Val->>DB: Check destination configured
    Val->>DB: Check Meta connection exists
    Val-->>API: Validation result
    
    alt Validation Failed
        API->>DB: UPDATE ads SET status='draft'
        API-->>UI: {success: false, error: {code, message}}
        UI->>U: Show error modal
    else Validation Passed
        API->>DB: SELECT campaign_meta_connections
        DB-->>API: Meta token + ad account
        
        API->>Meta: POST /act_{id}/campaigns<br/>{name, objective, status}
        Meta-->>API: {id: "campaign_123"}
        
        API->>Meta: POST /campaign_123/adsets<br/>{name, targeting, budget}
        Meta-->>API: {id: "adset_456"}
        
        API->>Meta: POST /adset_456/ads<br/>{name, creative, adcreatives}
        Meta-->>API: {id: "ad_789"}
        
        API->>DB: UPDATE ads SET<br/>meta_ad_id='ad_789'<br/>status='active'
        DB-->>API: Ad updated
        DB->>RT: Broadcast status='active'
        RT-->>UI: Realtime event
        
        API->>DB: INSERT ad_status_transitions
        API->>DB: INSERT ad_publishing_metadata
        
        API-->>UI: {success: true, data: {meta_ad_id: 'ad_789'}}
        UI->>U: Show "Ad Live!" success
    end
```

## Lead Capture Flow

```mermaid
sequenceDiagram
    participant User as Facebook User
    participant FB as Facebook App
    participant Meta as Meta Lead Gen API
    participant WH as Webhook Handler<br/>/api/v1/leads/webhook
    participant DB as Supabase
    participant CRM as CRM Webhook (optional)
    participant UI as AdPilot UI
    
    User->>FB: Fill & submit lead form
    FB->>Meta: Submit lead data
    Meta->>Meta: Store lead
    
    Meta->>WH: POST webhook<br/>{leadgen_id, form_id, ad_id}
    Note over WH: Public endpoint<br/>No auth required
    
    WH->>WH: Verify Meta signature
    WH->>DB: INSERT meta_webhook_events<br/>(raw payload)
    
    WH->>Meta: GET /leadgen_id?fields=field_data
    Meta-->>WH: {field_data: [{name, values}]}
    
    WH->>WH: Map Meta fields to<br/>normalized form_data
    
    WH->>DB: INSERT lead_form_submissions<br/>{campaign_id, form_data, submitted_at}
    DB-->>WH: Lead stored
    
    WH->>DB: Realtime broadcast
    DB->>UI: Realtime event
    UI->>UI: Update leads table
    
    alt CRM Webhook Configured
        WH->>CRM: POST webhook<br/>{lead_data, HMAC signature}
        CRM-->>WH: 200 OK
        WH->>DB: UPDATE lead SET webhook_sent=true
    end
    
    WH-->>Meta: 200 OK
    
    Note over UI: Lead appears in<br/>leads table automatically
```

---

# 10. Performance Architecture

## Query Performance

### Optimization Strategy

```mermaid
graph LR
    Query[API Query]
    
    Query --> Check{Has Index?}
    
    Check -->|Yes| IdxScan[Index Scan<br/>~5ms]
    Check -->|No| TableScan[Table Scan<br/>~50ms]
    
    IdxScan --> Cache{Cacheable?}
    TableScan --> Cache
    
    Cache -->|Static Data| C5[5min Cache<br/>s-maxage=300]
    Cache -->|User Data| C1[1min Cache<br/>s-maxage=60]
    Cache -->|Realtime| NC[No Cache<br/>no-store]
    
    C5 --> Response[Response to Client]
    C1 --> Response
    NC --> Response
    
    style IdxScan fill:#10b981,color:#fff
    style TableScan fill:#ef4444,color:#fff
    style C5 fill:#3b82f6,color:#fff
    style C1 fill:#3b82f6,color:#fff
```

### Performance Metrics

| Query Type | Before (no index) | After (with index) | Improvement |
|---|---|---|---|
| Campaign list | ~50ms (table scan) | ~5ms (index scan) | 10x faster |
| Ad list by campaign | ~30ms (table scan) | ~3ms (index scan) | 10x faster |
| Lead list | ~100ms (table + JSONB) | ~15ms (index + JSONB) | 6.7x faster |
| Meta connection lookup | ~20ms | ~2ms | 10x faster |
| Message pagination | ~40ms | ~4ms | 10x faster |

### Caching Strategy

| Endpoint | Cache Type | Duration | Rationale |
|---|---|---|---|
| `/api/v1/campaigns` | Private | 60s, stale-while-revalidate 300s | User-specific, updates infrequent |
| `/api/v1/ads` | None | no-store | Real-time status updates |
| `/api/v1/meta/assets` | Private | 300s, stale-while-revalidate 600s | Meta assets change rarely |
| `/api/v1/meta/metrics` | Private | 60s, stale-while-revalidate 300s | Metrics update periodically |
| `/api/v1/leads` | None | no-store | Real-time lead submissions |

### Query Optimization Techniques

**1. Select Only Needed Fields**
```sql
-- Bad: SELECT *
SELECT * FROM campaigns WHERE user_id = 'xxx'

-- Good: Explicit fields
SELECT id, name, status, updated_at FROM campaigns WHERE user_id = 'xxx'
```

**2. Use Composite Indexes**
```sql
-- Optimizes: WHERE campaign_id = X AND status = Y ORDER BY created_at
CREATE INDEX idx_ads_campaign_status_created 
ON ads(campaign_id, status, created_at DESC);
```

**3. Parallel Fetching**
```typescript
// Fetch Meta assets in parallel
const [businesses, pages, adAccounts] = await Promise.all([
  fetchBusinesses({ token }),
  fetchPagesWithTokens({ token }),
  fetchAdAccounts({ token })
])
```

---

# 11. Migration Strategy

## Migration Phases

```mermaid
graph LR
    Old[Old API<br/>71 files<br/>Still functional]
    V1[v1 API<br/>26 files<br/>Built]
    Client[Client Code<br/>React components]
    Clean[Cleanup<br/>Remove old routes]
    
    Old -.->|Phase 1-4<br/>Build alongside| V1
    V1 -.->|Phase 5<br/>Create API client| Client
    Client -.->|Phase 6<br/>Update components| Client
    Client -.->|Uses both during<br/>migration period| Old
    Client -.->|Uses both during<br/>migration period| V1
    Client -.->|Phase 7<br/>Switch fully to v1| V1
    Old -.->|After migration<br/>complete| Clean
    Clean -.-> X[üóëÔ∏è Deleted<br/>40 files]
    
    style Old fill:#fca5a5,stroke:#333
    style V1 fill:#86efac,stroke:#333
    style Client fill:#93c5fd,stroke:#333
    style Clean fill:#fbbf24,stroke:#333
    style X fill:#ef4444,color:#fff
```

## Migration Timeline

| Phase | Week | Status | Deliverable |
|---|---|---|---|
| **Phase 1-4** | ‚úÖ Done | Complete | v1 API built (26 routes) |
| **Phase 8** | ‚úÖ Done | Complete | Supabase configured |
| **Phase 5** | Week 1 | ‚è∏Ô∏è To Do | API client + hooks |
| **Phase 6** | Week 2 | ‚è∏Ô∏è To Do | Update components |
| **Phase 7** | Week 3 | ‚è∏Ô∏è To Do | Deploy & test |
| **Cleanup** | Week 4 | ‚è∏Ô∏è To Do | Remove old routes |

## Rollback Strategy

Since old routes remain functional during migration:

```mermaid
graph TD
    Issue{Issue<br/>Detected?}
    
    Issue -->|No| Continue[Continue Migration]
    Issue -->|Yes| Assess{Severity?}
    
    Assess -->|Minor| Fix[Fix in v1<br/>Redeploy]
    Assess -->|Critical| Rollback[Revert Client Code<br/>Use Old API]
    
    Fix --> Test[Test Fix]
    Test -->|Pass| Continue
    Test -->|Fail| Rollback
    
    Rollback --> OldAPI[Old API<br/>Still functional]
    OldAPI --> Monitor[Monitor<br/>Plan new fix]
    Monitor --> Fix
    
    style Issue fill:#f59e0b,color:#000
    style Rollback fill:#ef4444,color:#fff
    style OldAPI fill:#10b981,color:#fff
```

**Rollback Steps:**
1. Revert client code to previous commit
2. Deploy revert to production
3. Old API still works (no downtime)
4. Fix v1 issues
5. Re-attempt migration

**Risk:** Very Low - Old routes remain functional

---

# 12. Technology Stack

## Complete Stack Overview

| Layer | Technology | Version | Purpose |
|---|---|---|---|
| **Frontend Framework** | Next.js | 15.4.6 | React framework, API routes |
| **UI Library** | React | 18.x | Component library |
| **State Management** | TanStack Query | Latest | Server state, caching |
| **UI Components** | shadcn/ui | Latest | Component library |
| **Styling** | Tailwind CSS | Latest | Utility-first CSS |
| **Database** | Supabase (PostgreSQL) | 17.x | Data persistence, auth, realtime |
| **AI Chat** | Vercel AI SDK v5 | 5.x | Streaming chat, tool calling |
| **AI Provider** | OpenAI | GPT-4o | LLM for chat & naming |
| **Image Generation** | OpenAI DALL-E | 3 | Creative image generation |
| **Meta Integration** | Meta Marketing API | v24.0 | Ad publishing, leads, metrics |
| **Type Safety** | TypeScript | 5.x | Static typing |
| **Deployment** | Vercel | Latest | Hosting, CI/CD |
| **Monitoring** | Vercel Analytics | Latest | Performance monitoring |

## Dependency Versions

**Key Dependencies:**
```json
{
  "next": "15.4.6",
  "@supabase/supabase-js": "^2.x",
  "@supabase/ssr": "^0.x",
  "ai": "^5.x",
  "@tanstack/react-query": "^5.x",
  "zod": "^3.x",
  "typescript": "^5.x"
}
```

## Architecture Decisions

| Decision | Rationale | Trade-offs |
|---|---|---|
| **Flat API Structure** | Simpler routing, ownership via DB | Breaking change for clients |
| **Query Param Filtering** | Explicit, cacheable | More verbose URLs |
| **Supabase for Backend** | Realtime, auth, RLS built-in | Vendor lock-in |
| **Type Guards vs Zod** | No runtime dependencies | More boilerplate |
| **In-Memory Rate Limiting** | Simple, no Redis needed | Lost on restart (acceptable for now) |
| **campaign_meta_connections Table** | Single source of truth | Migration from localStorage |

---

# 13. Location Targeting Architecture

## Overview

Location targeting is a core feature that allows users to define geographical areas for their ad campaigns. The system uses a **single source of truth** approach where location data is stored at the ad level, ensuring each ad can have independent location targeting.

## Data Storage

### Storage Location
- **Primary:** `ads.setup_snapshot.location` (JSONB column)
- **Format:** LocationSnapshot object containing array of location objects
- **Isolation:** Each ad has independent location targeting

### LocationSnapshot Structure
```typescript
interface LocationSnapshot {
  locations: Array<{
    id: string
    name: string                // Full display name (e.g., "Toronto, Ontario, Canada")
    coordinates: [number, number] // [longitude, latitude]
    radius: number              // For radius-based targeting (miles)
    type: 'city' | 'region' | 'country' | 'radius'
    mode: 'include' | 'exclude'
    bbox?: [number, number, number, number] // Bounding box [minLng, minLat, maxLng, maxLat]
    geometry?: GeoJSONGeometry  // Boundary shape for map display
    key?: string                // Meta location key (required for publishing)
    country_code?: string       // ISO country code
  }>
  status: 'idle' | 'setup-in-progress' | 'completed' | 'error'
}
```

## Geocoding

### Provider
- **Service:** OpenStreetMap Nominatim API (free, no API key required)
- **Endpoint:** `https://nominatim.openstreetmap.org/search`
- **Features:** Forward geocoding, bounding boxes, boundary geometry

### Caching
- **Type:** In-memory Map cache
- **TTL:** 1 hour
- **Purpose:** Reduce API calls for repeated location searches

### Boundary Data
- **Format:** GeoJSON geometry
- **Purpose:** Display location shapes on Leaflet map
- **Fetching:** Separate API call for detailed boundaries

## Meta Integration

### Meta Location Keys
- **Purpose:** Required for publishing to Meta Ads API
- **Format:** Numeric string (e.g., "2490299" for Toronto)
- **Lookup:** Via Meta Location Search API (not yet implemented)
- **Validation:** Pre-publish validator checks for missing keys

### Location Types Mapping
| Internal Type | Meta Format | Requires Key? |
|--------------|-------------|---------------|
| `country` | `countries: ["US", "CA"]` | No (uses ISO code) |
| `region` | `regions: [{key: "3847"}]` | Yes |
| `city` | `cities: [{key: "2490299"}]` | Yes |
| `radius` | `custom_locations: [{...}]` | Yes (for center) |

## AI Integration

### Flow Overview
1. User clicks "Add Location" button in LocationSelectionCanvas
2. LocationContext.startLocationSetup() validates active ad exists
3. Event dispatched to AI chat: `requestLocationSetup`
4. AI chat stops current work (if any) and asks: "What location would you like to target?"
5. User responds with location name(s)
6. Metadata injected: `{locationSetupMode: true, locationInput: "Toronto"}`
7. System prompt enforces AI must call `locationTargeting` tool
8. LocationTargetingProcessor component geocodes and fetches boundaries
9. Location data saved to ad snapshot via LocationContext
10. Map updates automatically via Leaflet

### Metadata Enforcement
The system uses metadata to guarantee the AI calls the `locationTargeting` tool:

```typescript
// In chat API route
if (isLocationSetupMode && locationInput) {
  systemInstructions += `
üéØ CRITICAL: LOCATION SETUP MODE ACTIVE
You MUST call locationTargeting tool NOW with: "${locationInput}"
No exceptions. Do not ask questions or call other tools.
`
}
```

## Component Architecture

### Key Components
| Component | Purpose |
|-----------|---------|
| `LocationContext` | State management, single save path |
| `LocationSelectionCanvas` | Map display (Leaflet), add/remove UI |
| `LocationTargetingProcessor` | Geocoding, boundary fetching, Meta key lookup |
| `location-targeting-tool.ts` | AI tool definition |
| `targeting-transformer.ts` | Convert to Meta TargetingSpec |
| `pre-publish-validator.ts` | Validate before publishing |

### Data Flow
```
User ‚Üí LocationContext ‚Üí Ad Snapshot ‚Üí Database
  ‚Üì
AI Tool Call ‚Üí Geocoding ‚Üí Location Data
  ‚Üì
Map Update (Leaflet) ‚Üê Location Data
```

## Publishing Integration

### Pre-Publish Validation
1. Check `ad.setup_snapshot.location` for location data
2. Validate Meta keys exist for all non-country locations
3. If missing keys: block publish with error message
4. Transform locations to Meta TargetingSpec format

### Targeting Transformer
```typescript
// Example transformation
{
  locations: [{
    name: "Toronto, Ontario, Canada",
    type: "city",
    mode: "include",
    key: "2490299"
  }]
}
// Becomes:
{
  geo_locations: {
    cities: [{ key: "2490299", name: "Toronto" }]
  }
}
```

## Error Handling

### Geocoding Failures
- **Not Found:** Show user-friendly error: "Location not found. Try a more specific name."
- **API Error:** Log error, show generic message: "Geocoding service unavailable"
- **Invalid Input:** Validate minimum 2 characters

### Missing Meta Keys
- **During Setup:** Log warning (keys will be fetched when Meta API is integrated)
- **Pre-Publish:** Block publish with error and suggested action
- **Publishing:** Throw error if key missing (prevents invalid API call)

## Future Enhancements

### Phase 2 - Meta Location Search API
- Integrate Meta Location Search API for real-time key lookup
- Replace OSM-only geocoding with Meta's location database
- Support DMA (Designated Market Area) targeting
- Add location suggestions/autocomplete

### Phase 3 - Advanced Features
- Saved location sets (e.g., "US Major Cities")
- Location recommendations based on campaign goal
- Competitor location analysis
- Location performance analytics

---

## Summary

This architecture provides:
- ‚úÖ **26 lean API routes** (63% reduction from 71)
- ‚úÖ **Type-safe throughout** (0 `any` types)
- ‚úÖ **Multi-layer security** (API + RLS + types)
- ‚úÖ **High performance** (12 optimized indexes)
- ‚úÖ **Real-time updates** (Supabase subscriptions)
- ‚úÖ **Easy to maintain** (shared middleware, standards)
- ‚úÖ **Scalable design** (resource-based, flat structure)
- ‚úÖ **Ad-level location targeting** (isolated, single source of truth)

**Ready for production deployment and future growth.**

---

*AdPilot Master Project Architecture*  
*Version 1.0 - November 15, 2025*

---

## 14. Journey-Based Microservices Architecture (Current Implementation)

### Overview

AdPilot AI chat uses journey-based microservices where each user workflow is an independent service module.

### Journey Module Structure

```
components/chat/
‚îú‚îÄ‚îÄ chat-container.tsx (104 lines)     # Lean orchestrator
‚îú‚îÄ‚îÄ message-renderer.tsx (48 lines)    # Routing layer
‚îú‚îÄ‚îÄ journeys/                          # Independent services
‚îÇ   ‚îú‚îÄ‚îÄ location/ (3 files, 163 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ location-journey.tsx       # Rendering
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ use-location-mode.ts       # Mode state (fixes exclude bug)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ location-metadata.ts       # Metadata builder
‚îÇ   ‚îú‚îÄ‚îÄ creative/ (135 lines)
‚îÇ   ‚îú‚îÄ‚îÄ copy/ (70 lines)
‚îÇ   ‚îú‚îÄ‚îÄ goal/ (95 lines)
‚îÇ   ‚îî‚îÄ‚îÄ campaign/ (45 lines)
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ use-journey-router.ts (52 lines)
‚îÇ   ‚îî‚îÄ‚îÄ use-metadata-builder.ts (46 lines)
‚îî‚îÄ‚îÄ types/
    ‚îú‚îÄ‚îÄ journey-types.ts (40 lines)
    ‚îú‚îÄ‚îÄ chat-types.ts (46 lines)
    ‚îî‚îÄ‚îÄ metadata-types.ts (54 lines)
```

### Journey Interface Contract

```typescript
export interface Journey {
  renderTool: (part: ToolPart) => React.ReactNode;
  buildMetadata?: (input: string) => Record<string, unknown>;
  reset?: () => void;
  mode?: 'include' | 'exclude';
  isActive?: boolean;
}
```

### Location Journey (Reference Implementation)

**Excludemode fix**: The `useLocationMode` hook stores mode state independently, preventing loss in monolithic code.

**Flow**:
```
Click "Exclude Location"
    ‚Üì
useLocationMode receives event { mode: 'exclude' }
    ‚Üì
Hook stores mode = 'exclude'
    ‚Üì
User types "toronto"
    ‚Üì
createLocationMetadata('exclude', 'toronto')
    ‚Üì
Metadata: { locationMode: 'exclude', locationInput: 'toronto' }
    ‚Üì
AI checks metadata.locationMode FIRST
    ‚Üì
AI calls addLocations with mode='exclude'
    ‚Üì
POST /api/v1/ads/[id]/locations/exclude
    ‚Üì
Database: inclusion_mode='exclude'
    ‚Üì
UI: RED card, RED map, "Excluded" section
```

### Testing Journey Modules

Test suite: `tests/journeys/`
- location-journey.test.ts (113 lines)
- journey-router.test.ts (93 lines)
- metadata-builder.test.ts (65 lines)

Run: `npm test tests/journeys/`

---

*AdPilot Master Project Architecture - Updated November 18, 2025*
