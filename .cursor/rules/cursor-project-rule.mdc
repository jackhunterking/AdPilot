---
alwaysApply: true
---
# Cursor Project Rule

**Applies to:** this repository and all Cursor-generated changes.

## Purpose

Guarantee every feature is designed and implemented using the official references for:

* **Vercel AI SDK V5 (Core)** — `https://ai-sdk.dev/docs/introduction`
* **AI Elements** — `https://ai-sdk.dev/elements/overview`
* **Vercel AI Gateway** — `https://vercel.com/docs/ai-gateway`
* **Supabase (Backend & Storage/Auth/DB/Edge Functions)** — `https://supabase.com/docs`

## Non‑negotiable Rules

1. **Always consult docs first.** Before writing code or UI, read the relevant sections of the four docs above. Prefer the **latest, canonical examples** from these pages.
2. **Cite sources inline.** In every PR description and major file header, include a short “References” block with exact doc section URLs used for that change.
3. **Use the official patterns.**

   * AI calls must use **Vercel AI SDK V5 (Core)** idioms (streaming, tool calling, providers) and **AI Gateway** for routing/observability.
   * UI must use **AI Elements** components when building chat/assistants, rather than custom re‑implementations.
   * All backend data, auth, storage, RLS, and edge functions must use **Supabase** clients and recommended patterns.
4. **No ad‑hoc providers or unvetted libs.** If a feature needs a new model/provider, it must go through AI Gateway and follow AI SDK docs.
5. **Type safety & envs.** Strong TypeScript types, zod (or equivalent) for I/O boundaries, and `env` variables managed via `.env.local` with typed access.
6. This project must use **Vercel AI SDK V5 versioning ONLY. DO NOT USE LOWER VERSIONS.
7. This will be build in vercel se pay attention to potential typescripts errors and eslint errors.

## Microservices Architecture Philosophy

**Core Principle:** This project follows a **microservices mindset**, not a monolithic approach. Every feature must be designed with modularity, separation of concerns, and independent deployability in mind.

### Before You Build: Think & Plan

Before implementing any feature, you MUST:

1. **Decompose the feature** into independent, bounded services/modules
2. **Identify clear boundaries** between services (data ownership, responsibilities)
3. **Define contracts** (API interfaces, types, events) between services
4. **Plan for independence** - each service should be deployable, testable, and maintainable separately

### Microservices Architecture Patterns

#### 1. API Route Services
- Each API route (`app/api/*`) should be a self-contained service
- Services communicate via well-defined REST/GraphQL endpoints
- No direct imports of business logic across service boundaries
- Use shared types/interfaces in `lib/types/` for contracts

```typescript
// ✅ Good: Independent service with clear contract
// app/api/campaigns/create/route.ts
export async function POST(req: NextRequest) {
  // Self-contained campaign creation logic
  // Calls other services via fetch/HTTP
}

// ❌ Bad: Monolithic approach
// app/api/campaigns/create/route.ts
import { adLogic } from '../../ads/logic' // Direct coupling
```

#### 2. Supabase Edge Functions as Services
- Complex business logic should live in Supabase Edge Functions
- Frontend/API routes orchestrate, Edge Functions execute domain logic
- Each Edge Function is an independent microservice
- Use RPC calls or REST to communicate between functions

#### 3. Service Layer Pattern
- Organize `lib/` into service modules: `lib/services/campaign-service.ts`, `lib/services/ad-service.ts`
- Each service module owns its domain logic
- Services can depend on other services via dependency injection, not direct imports

```typescript
// ✅ Good: Service with injected dependencies
export class CampaignService {
  constructor(
    private readonly adService: AdService,
    private readonly analyticsService: AnalyticsService
  ) {}
  
  async createCampaign(data: CampaignInput) {
    // Campaign-specific logic only
    const ads = await this.adService.generateAds(data);
    await this.analyticsService.track('campaign_created');
  }
}
```

#### 4. Event-Driven Communication
- Use Supabase Realtime/Webhooks for async service communication
- Prefer events over direct calls when services don't need immediate response
- Define event schemas in `lib/types/events.ts`

#### 5. Shared Kernel (Minimal)
- Only share: types, interfaces, utility functions, constants
- Shared code lives in: `lib/types/`, `lib/utils/`, `lib/constants.ts`
- NO shared business logic or state

### Module Boundaries

```
app/api/
  ├── campaigns/          # Campaign Management Service
  ├── ads/                # Ad Creation/Management Service
  ├── analytics/          # Analytics Service
  ├── meta/               # Meta Platform Integration Service
  └── images/             # Image Generation Service

lib/services/
  ├── campaign-service.ts # Campaign domain logic
  ├── ad-service.ts       # Ad domain logic
  └── meta-api-client.ts  # Meta API client (shared infrastructure)

supabase/functions/
  ├── process-campaign/   # Campaign processing microservice
  ├── generate-copy/      # AI copy generation microservice
  └── sync-meta-data/     # Meta data sync microservice
```

### Anti-Patterns to Avoid

❌ **Don't:**
- Create god objects or services that do everything
- Import business logic directly across service boundaries
- Share database models/schemas between services (use API contracts)
- Build tightly coupled components that can't be tested independently
- Mix UI concerns with business logic
- Create circular dependencies between services

✅ **Do:**
- Think "How would this work if it were deployed separately?"
- Define explicit interfaces/contracts between services
- Keep services small, focused on single responsibility
- Use composition over inheritance
- Design for horizontal scalability
- Write integration tests that mock external services

### Planning Checklist (Before Coding)

For every new feature or major change, document:

- [ ] **Service Boundaries:** What services are involved? What's each responsible for?
- [ ] **Contracts:** What are the input/output types? API endpoints? Events?
- [ ] **Dependencies:** Which services depend on which? How do they communicate?
- [ ] **Data Ownership:** Which service owns what data? How is it accessed?
- [ ] **Deployment:** Can this service be deployed independently? What breaks if it's down?
- [ ] **Testing:** Can I test this service in isolation with mocked dependencies?

### Example: Creating a New Feature

**Feature:** "Automated A/B Test Campaign Creation"

**❌ Monolithic Thinking:**
"I'll add a big function in `campaign-workspace.tsx` that handles campaign creation, ad generation, Meta API calls, analytics tracking, and UI updates all in one file."

**✅ Microservices Thinking:**
1. **Campaign Service** (`lib/services/campaign-service.ts`): Orchestrates campaign creation workflow
2. **Ad Variation Service** (`lib/services/ad-variation-service.ts`): Generates A/B test variations
3. **Meta Publishing Service** (`lib/services/meta-publishing-service.ts`): Handles Meta API interactions
4. **Analytics Service** (`lib/services/analytics-service.ts`): Tracks campaign events
5. **API Route** (`app/api/campaigns/ab-test/route.ts`): Thin controller, delegates to services
6. **UI Component** (`components/ab-test/ab-test-builder.tsx`): Pure presentation, calls API

Each service is:
- Independently testable
- Has clear responsibilities
- Can be moved to Edge Function if needed
- Communicates via defined contracts

Vercel builds must never fail due to ESLint.

Cursor must avoid any by default and generate proper, narrow types.

Linting remains useful locally/CI without blocking deploys.

Apply this rule to all new and edited files.

Build behavior (must be enforced)

Next config: skip ESLint during next build

If next.config.{js,ts} exists, ensure:

/** @type {import('next').NextConfig} */
const nextConfig = { eslint: { ignoreDuringBuilds: true } };
module.exports = nextConfig;


If config already exists, merge (do not overwrite unrelated settings).

ESLint config (guardrail, not blocker)

Ensure .eslintrc.json contains:

{
  "extends": ["next/core-web-vitals"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/consistent-type-imports": "error",
    "no-restricted-syntax": [
      "warn",
      { "selector": "TSTypeReference[typeName.name='any']", "message": "Do not use 'any' types." }
    ]
  }
}


Never weaken other rules unless required by Next.

Scripts

Ensure package.json has:

{
  "scripts": {
    "lint": "next lint",
    "lint:strict": "next lint --max-warnings=0",
    "typecheck": "tsc --noEmit"
  }
}


TypeScript strictness

Ensure tsconfig.json includes:

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noFallthroughCasesInSwitch": true
  }
}


Ignore noisy/generated paths

Ensure .eslintignore includes:

node_modules
.next
dist
public
**/generated/**
**/*.d.ts

Authoring code (Cursor must follow)

Never introduce any. Prefer concrete types, unknown + narrowing, or Record<string, unknown>.

Always type:

React handlers: React.ChangeEvent<HTMLInputElement|HTMLTextAreaElement|HTMLSelectElement>

Next API: NextRequest / NextResponse

Fetch JSON: unknown then narrow before use.

Create/reuse minimal interfaces for SDKs (e.g., Facebook/Meta) under src/types/ and import them instead of any.

Required patterns
// Good: fetch + narrowing
const json: unknown = await fetch(url).then(r => r.json());
function isMe(x: unknown): x is { id: string; name?: string } {
  return typeof x === "object" && x !== null && typeof (x as any).id === "string";
}
if (isMe(json)) {
  const { id } = json;
}

// Good: event typing
function onChange(e: React.ChangeEvent<HTMLInputElement>) {
  setValue(e.target.value);
}

// Good: generic objects
type Dict = Record<string, unknown>;

Types scaffold (auto-create if missing)

Create src/types/common.ts with:

export type Dict = Record<string, unknown>;

export interface FbMe { id: string; name?: string }
export interface FbToken { access_token: string; token_type?: string; expires_in?: number }

// Add feature-specific types nearby to usage files, then re-export here for reuse.

Local/CI policy (optional but recommended)

Run npm run typecheck && npm run lint locally.

In CI, use npm run lint:strict to fail on warnings if you want zero-tolerance, but Vercel builds must not fail due to ESLint because ignoreDuringBuilds=true.

File/line exceptions (rare)

If an SDK/shim truly requires any, use a single-line suppression with a comment why:

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- SDK callback has polymorphic shape we don't control
function shim(x: any) { /* ... */ }


Avoid file-wide disables.

Ready-to-paste configs (if you want them now)

next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: { ignoreDuringBuilds: true },
};
module.exports = nextConfig;


.eslintrc.json

{
  "extends": ["next/core-web-vitals"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/consistent-type-imports": "error",
    "no-restricted-syntax": [
      "warn",
      { "selector": "TSTypeReference[typeName.name='any']", "message": "Do not use 'any' types." }
    ]
  }
}


tsconfig.json (partial)

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noFallthroughCasesInSwitch": true
  }
}


.eslintignore

node_modules
.next
dist
public
**/generated/**
**/*.d.ts

## Definition of Done (per task)

* [ ] **Microservices Planning:** Service boundaries identified, contracts defined, dependencies documented (see Planning Checklist)
* [ ] **Service Independence:** Each service can be tested/deployed independently with clear responsibilities
* [ ] **Design note** links to the exact doc sections used.
* [ ] **API client** created/updated using AI SDK Core examples.
* [ ] **UI** built with AI Elements where applicable.
* [ ] **AI Gateway** config added (routes/keys/observability) as per docs.
* [ ] **Supabase**: schema, RLS, auth flow, and queries implemented by copying/adapting official examples.
* [ ] **No tight coupling:** Services communicate via APIs/events, not direct imports of business logic
* [ ] **References** block in PR (copy/paste template below).
* [ ] **Smoke test** steps included.

## File Header Template (paste at top of new/edited files)

```md
/**
 * Feature: <short title>
 * Purpose: <what this file does>
 * References:
 *  - AI SDK Core: https://ai-sdk.dev/docs/introduction#<section>
 *  - AI Elements: https://ai-sdk.dev/elements/overview#<section>
 *  - Vercel AI Gateway: https://vercel.com/docs/ai-gateway#<section>
 *  - Supabase: https://supabase.com/docs/<product>/<section>
 */
```

## PR Description Template

```
### What & Why
<1–3 sentences>

### Architecture (Microservices)
- **Services involved:** <list services/modules created or modified>
- **Service boundaries:** <how responsibilities are separated>
- **Communication pattern:** <API calls, events, RPC, etc.>
- **Independence:** <can be deployed/tested separately? any dependencies?>

### Implementation Notes
- Followed AI SDK Core pattern for <streaming/tool calling/etc>.
- Used AI Elements <ComponentName> for <chat/input/history>.
- Routed model traffic via AI Gateway <config link/notes>.
- Supabase <auth/storage/db> per docs <links>.

### References
- AI SDK Core: <exact section URL>
- AI Elements: <exact section URL>
- AI Gateway: <exact section URL>
- Supabase: <exact section URL>

### Test Plan
1) <steps>
2) <expected output>
```

## Enforcement

* Cursor: Always expand the **References** block before proposing code.
* If a suggestion contradicts the linked docs, prefer the docs and note the discrepancy.
* When docs show multiple options, choose the simplest **official** path first.
**You have MCP access for Supabase. You can securely execute queries, updates, and schema operations automatically via MCP. Always ensure operations are safe, efficient, and follow Supabase best practices. NOT THE SAME AS SUPABASE AI, IT IS CURSOR MCP FOR SUPABASE**

## Quick Links

* AI SDK Core — [https://ai-sdk.dev/docs/introduction](https://ai-sdk.dev/docs/introduction)
* AI Elements — [https://ai-sdk.dev/elements/overview](https://ai-sdk.dev/elements/overview)
* Vercel AI Gateway — [https://vercel.com/docs/ai-gateway](https://vercel.com/docs/ai-gateway)
* Supabase — [https://supabase.com/docs](https://supabase.com/docs)
