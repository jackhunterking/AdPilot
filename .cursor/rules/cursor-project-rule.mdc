---
alwaysApply: true
---
# Cursor Project Rule

**Applies to:** this repository and all Cursor-generated changes.

## Purpose

Guarantee every feature is designed and implemented using the official references for:

* **Vercel AI SDK V5 (Core)** — `https://ai-sdk.dev/docs/introduction`
* **AI Elements** — `https://ai-sdk.dev/elements/overview`
* **Vercel AI Gateway** — `https://vercel.com/docs/ai-gateway`
* **Supabase (Backend & Storage/Auth/DB/Edge Functions)** — `https://supabase.com/docs`

## Non‑negotiable Rules

1. **Always consult docs first.** Before writing code or UI, read the relevant sections of the four docs above. Prefer the **latest, canonical examples** from these pages.
2. **Cite sources inline.** In every PR description and major file header, include a short “References” block with exact doc section URLs used for that change.
3. **Use the official patterns.**

   * AI calls must use **Vercel AI SDK V5 (Core)** idioms (streaming, tool calling, providers) and **AI Gateway** for routing/observability.
   * UI must use **AI Elements** components when building chat/assistants, rather than custom re‑implementations.
   * All backend data, auth, storage, RLS, and edge functions must use **Supabase** clients and recommended patterns.
4. **No ad‑hoc providers or unvetted libs.** If a feature needs a new model/provider, it must go through AI Gateway and follow AI SDK docs.
5. **Type safety & envs.** Strong TypeScript types, zod (or equivalent) for I/O boundaries, and `env` variables managed via `.env.local` with typed access.
6. This project must use **Vercel AI SDK V5 versioning ONLY. DO NOT USE LOWER VERSIONS.
7. This will be build in vercel se pay attention to potential typescripts errors and eslint errors.

## Microservices Architecture Philosophy

**Core Principle:** This project follows a **microservices mindset**, not a monolithic approach. Every feature must be designed with modularity, separation of concerns, and independent deployability in mind.

### Before You Build: Think & Plan

Before implementing any feature, you MUST:

1. **Decompose the feature** into independent, bounded services/modules
2. **Identify clear boundaries** between services (data ownership, responsibilities)
3. **Define contracts** (API interfaces, types, events) between services
4. **Plan for independence** - each service should be deployable, testable, and maintainable separately
5. **Consider journey decomposition** - Can this be a journey module? What workflow does it handle?
6. **Identify service layer needs** - What business logic services are required?

### Microservices Architecture Patterns

#### 1. API Route Services
- Each API route (`app/api/*`) should be a self-contained service
- Services communicate via well-defined REST/GraphQL endpoints
- No direct imports of business logic across service boundaries
- Use shared types/interfaces in `lib/types/` for contracts

```typescript
// ✅ Good: Independent service with clear contract
// app/api/campaigns/create/route.ts
export async function POST(req: NextRequest) {
  // Self-contained campaign creation logic
  // Calls other services via fetch/HTTP
}

// ❌ Bad: Monolithic approach
// app/api/campaigns/create/route.ts
import { adLogic } from '../../ads/logic' // Direct coupling
```

#### 2. Supabase Edge Functions as Services
- Complex business logic should live in Supabase Edge Functions
- Frontend/API routes orchestrate, Edge Functions execute domain logic
- Each Edge Function is an independent microservice
- Use RPC calls or REST to communicate between functions

#### 3. Service Layer Pattern
- Organize `lib/` into service modules: `lib/services/campaign-service.ts`, `lib/services/ad-service.ts`
- Each service module owns its domain logic
- Services can depend on other services via dependency injection, not direct imports

```typescript
// ✅ Good: Service with injected dependencies
export class CampaignService {
  constructor(
    private readonly adService: AdService,
    private readonly analyticsService: AnalyticsService
  ) {}
  
  async createCampaign(data: CampaignInput) {
    // Campaign-specific logic only
    const ads = await this.adService.generateAds(data);
    await this.analyticsService.track('campaign_created');
  }
}
```

#### 4. Event-Driven Communication
- Use Supabase Realtime/Webhooks for async service communication
- Prefer events over direct calls when services don't need immediate response
- Define event schemas in `lib/types/events.ts`

#### 5. Shared Kernel (Minimal)
- Only share: types, interfaces, utility functions, constants
- Shared code lives in: `lib/types/`, `lib/utils/`, `lib/constants.ts`
- NO shared business logic or state

#### 6. Journey-Oriented Design
- Each user workflow is an independent journey module
- Journeys render AI tool invocations and manage workflow state
- Example: CreativeJourney, CopyJourney, LocationJourney (10 total)
- Journeys implement a standard interface: `Journey<TState>`
- Journey modules are self-contained and independently testable

```typescript
// Journey interface contract
interface Journey<TState extends JourneyState> {
  id: string;
  renderTool: (part: ToolPart) => React.ReactNode;
  buildMetadata?: (input: string) => JourneyMetadata;
  reset?: () => void;
  getState?: () => TState;
  setState?: (state: Partial<TState>) => void;
  onActivate?: () => void;
  onDeactivate?: () => void;
}
```

#### 7. Service Layer with Dependency Injection
- All business logic lives in services, not components
- Services implement `ServiceContract<TInput, TOutput>`
- Components are thin orchestrators that delegate to services
- Use ServiceProvider for dependency injection
- Services return standardized `ServiceResult<T>` objects

```typescript
// Service contract
interface ServiceContract<TInput, TOutput> {
  execute: (input: TInput) => Promise<ServiceResult<TOutput>>;
  validate?: (input: TInput) => ValidationResult;
}

// Service result
interface ServiceResult<TData> {
  success: boolean;
  data?: TData;
  error?: {
    code: string;
    message: string;
    details?: unknown;
  };
}

// Usage in components
const campaignService = useCampaignService();
const result = await campaignService.createCampaign.execute(input);
if (result.success) {
  // Handle success
}
```

#### 8. Testing Strategy
- Journey modules tested in isolation with test harness
- Services tested with mocked dependencies
- Integration tests mock external services
- Unit tests for pure functions and utilities
- E2E tests for critical workflows

### Module Boundaries

**See** `MASTER_PROJECT_ARCHITECTURE.mdc` for complete module structure.

**Key Principles:**
- API routes (`app/api/v1/*`) - REST endpoints
- Journeys (`components/chat/journeys/*`) - 10 user workflows
- Services (`lib/services/*`) - Business logic layer
- AI Services (`lib/ai/services/*`) - AI-specific logic

### Anti-Patterns to Avoid

❌ **Don't:**
- Create god objects or services that do everything
- Import business logic directly across service boundaries
- Share database models/schemas between services (use API contracts)
- Build tightly coupled components that can't be tested independently
- Mix UI concerns with business logic
- Create circular dependencies between services

✅ **Do:**
- Think "How would this work if it were deployed separately?"
- Define explicit interfaces/contracts between services
- Keep services small, focused on single responsibility
- Use composition over inheritance
- Design for horizontal scalability
- Write integration tests that mock external services

### Planning Checklist (Before Coding)

For every new feature or major change, document:

- [ ] **Journey Decomposition:** Can this be a journey module? What user workflow does it handle?
- [ ] **Service Boundaries:** What services are involved? What's each responsible for?
- [ ] **Contracts:** What are the input/output types? API endpoints? Events? Journey interfaces?
- [ ] **Dependencies:** Which services depend on which? How do they communicate?
- [ ] **Data Ownership:** Which service owns what data? How is it accessed?
- [ ] **Deployment:** Can this service/journey be deployed independently? What breaks if it's down?
- [ ] **Testing:** Can I test this service/journey in isolation with mocked dependencies?
- [ ] **Component Orchestration:** Are components thin orchestrators that delegate to services?

### Example: Creating a New Feature

**Feature:** "Automated A/B Test Campaign Creation"

**❌ Monolithic Thinking:**
"I'll add a big function in `campaign-workspace.tsx` that handles campaign creation, ad generation, Meta API calls, analytics tracking, and UI updates all in one file."

**✅ Microservices Thinking (Journey-Based):**

**Journey Layer (User Workflow):**
1. **AB Test Journey** (`components/chat/journeys/ab-test/ab-test-journey.tsx`): 
   - Renders AI tool invocations for A/B test setup
   - Manages workflow state (variations, metrics)
   - Builds metadata for AI context

**Service Layer (Business Logic):**
2. **Campaign Service** (`lib/services/campaign-service-impl.ts`): Orchestrates campaign creation workflow
3. **Ad Variation Service** (`lib/services/ad-variation-service.ts`): Generates A/B test variations
4. **Meta Publishing Service** (`lib/services/meta-publishing-service.ts`): Handles Meta API interactions
5. **Analytics Service** (`lib/services/analytics-service.ts`): Tracks campaign events

**API Layer (REST Endpoints):**
6. **API Route** (`app/api/v1/campaigns/ab-test/route.ts`): Thin controller, delegates to services

**Presentation Layer (UI):**
7. **UI Component** (`components/ab-test/ab-test-builder.tsx`): Pure presentation, delegates to journey/services

Each module is:
- Independently testable
- Has clear responsibilities
- Can be deployed/scaled independently
- Communicates via defined contracts (Journey interface, ServiceContract)
- Follows single responsibility principle

**Data Flow:**
User → Journey (renders workflow) → Service (business logic) → API → Database
UI ← Journey (updates state) ← Service (returns result) ← API ← Database

Vercel builds must never fail due to ESLint.

Cursor must avoid any by default and generate proper, narrow types.

Linting remains useful locally/CI without blocking deploys.

Apply this rule to all new and edited files.

Build behavior (must be enforced)

Next config: skip ESLint during next build

If next.config.{js,ts} exists, ensure:

/** @type {import('next').NextConfig} */
const nextConfig = { eslint: { ignoreDuringBuilds: true } };
module.exports = nextConfig;


If config already exists, merge (do not overwrite unrelated settings).

ESLint config (guardrail, not blocker)

Ensure .eslintrc.json contains:

{
  "extends": ["next/core-web-vitals"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/consistent-type-imports": "error",
    "no-restricted-syntax": [
      "warn",
      { "selector": "TSTypeReference[typeName.name='any']", "message": "Do not use 'any' types." }
    ]
  }
}


Never weaken other rules unless required by Next.

Scripts

Ensure package.json has:

{
  "scripts": {
    "lint": "next lint",
    "lint:strict": "next lint --max-warnings=0",
    "typecheck": "tsc --noEmit"
  }
}


TypeScript strictness

Ensure tsconfig.json includes:

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noFallthroughCasesInSwitch": true
  }
}


Ignore noisy/generated paths

Ensure .eslintignore includes:

node_modules
.next
dist
public
**/generated/**
**/*.d.ts

Authoring code (Cursor must follow)

Never introduce any. Prefer concrete types, unknown + narrowing, or Record<string, unknown>.

Always type:

React handlers: React.ChangeEvent<HTMLInputElement|HTMLTextAreaElement|HTMLSelectElement>

Next API: NextRequest / NextResponse

Fetch JSON: unknown then narrow before use.

Create/reuse minimal interfaces for SDKs (e.g., Facebook/Meta) under src/types/ and import them instead of any.

Required patterns
// Good: fetch + narrowing
const json: unknown = await fetch(url).then(r => r.json());
function isMe(x: unknown): x is { id: string; name?: string } {
  return typeof x === "object" && x !== null && typeof (x as any).id === "string";
}
if (isMe(json)) {
  const { id } = json;
}

// Good: event typing
function onChange(e: React.ChangeEvent<HTMLInputElement>) {
  setValue(e.target.value);
}

// Good: generic objects
type Dict = Record<string, unknown>;

Types scaffold (auto-create if missing)

Create src/types/common.ts with:

export type Dict = Record<string, unknown>;

export interface FbMe { id: string; name?: string }
export interface FbToken { access_token: string; token_type?: string; expires_in?: number }

// Add feature-specific types nearby to usage files, then re-export here for reuse.

Local/CI policy (optional but recommended)

Run npm run typecheck && npm run lint locally.

In CI, use npm run lint:strict to fail on warnings if you want zero-tolerance, but Vercel builds must not fail due to ESLint because ignoreDuringBuilds=true.

File/line exceptions (rare)

If an SDK/shim truly requires any, use a single-line suppression with a comment why:

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- SDK callback has polymorphic shape we don't control
function shim(x: any) { /* ... */ }


Avoid file-wide disables.

Ready-to-paste configs (if you want them now)

next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: { ignoreDuringBuilds: true },
};
module.exports = nextConfig;


.eslintrc.json

{
  "extends": ["next/core-web-vitals"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/consistent-type-imports": "error",
    "no-restricted-syntax": [
      "warn",
      { "selector": "TSTypeReference[typeName.name='any']", "message": "Do not use 'any' types." }
    ]
  }
}


tsconfig.json (partial)

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noFallthroughCasesInSwitch": true
  }
}


.eslintignore

node_modules
.next
dist
public
**/generated/**
**/*.d.ts

## Definition of Done (per task)

* [ ] **Microservices Planning:** Service boundaries identified, contracts defined, dependencies documented (see Planning Checklist)
* [ ] **Service Independence:** Each service can be tested/deployed independently with clear responsibilities
* [ ] **Design note** links to the exact doc sections used.
* [ ] **API client** created/updated using AI SDK Core examples.
* [ ] **UI** built with AI Elements where applicable.
* [ ] **AI Gateway** config added (routes/keys/observability) as per docs.
* [ ] **Supabase**: schema, RLS, auth flow, and queries implemented by copying/adapting official examples.
* [ ] **No tight coupling:** Services communicate via APIs/events, not direct imports of business logic
* [ ] **References** block in PR (copy/paste template below).
* [ ] **Smoke test** steps included.

## File Header Template (paste at top of new/edited files)

```md
/**
 * Feature: <short title>
 * Purpose: <what this file does>
 * References:
 *  - AI SDK Core: https://ai-sdk.dev/docs/introduction#<section>
 *  - AI Elements: https://ai-sdk.dev/elements/overview#<section>
 *  - Vercel AI Gateway: https://vercel.com/docs/ai-gateway#<section>
 *  - Supabase: https://supabase.com/docs/<product>/<section>
 */
```

## PR Description Template

```
### What & Why
<1–3 sentences>

### Architecture (Microservices)
- **Services involved:** <list services/modules created or modified>
- **Service boundaries:** <how responsibilities are separated>
- **Communication pattern:** <API calls, events, RPC, etc.>
- **Independence:** <can be deployed/tested separately? any dependencies?>

### Implementation Notes
- Followed AI SDK Core pattern for <streaming/tool calling/etc>.
- Used AI Elements <ComponentName> for <chat/input/history>.
- Routed model traffic via AI Gateway <config link/notes>.
- Supabase <auth/storage/db> per docs <links>.

### References
- AI SDK Core: <exact section URL>
- AI Elements: <exact section URL>
- AI Gateway: <exact section URL>
- Supabase: <exact section URL>

### Test Plan
1) <steps>
2) <expected output>
```

## Enforcement

* Cursor: Always expand the **References** block before proposing code.
* If a suggestion contradicts the linked docs, prefer the docs and note the discrepancy.
* When docs show multiple options, choose the simplest **official** path first.
**You have MCP access for Supabase. You can securely execute queries, updates, and schema operations automatically via MCP. Always ensure operations are safe, efficient, and follow Supabase best practices. NOT THE SAME AS SUPABASE AI, IT IS CURSOR MCP FOR SUPABASE**

## Quick Links

* AI SDK Core — [https://ai-sdk.dev/docs/introduction](https://ai-sdk.dev/docs/introduction)
* AI Elements — [https://ai-sdk.dev/elements/overview](https://ai-sdk.dev/elements/overview)
* Vercel AI Gateway — [https://vercel.com/docs/ai-gateway](https://vercel.com/docs/ai-gateway)
* Supabase — [https://supabase.com/docs](https://supabase.com/docs)

## Production Status

**Last Audit:** November 18, 2025  
**Status:** ✅ Production Ready  
**Build:** ✅ Passing | **TypeScript:** ✅ 0 Errors

### Microservices Audit Complete
- ✅ All 26 API v1 routes operational (100% middleware coverage)
- ✅ 12 server services implemented (8 new + 4 existing)
  - Note: Some AI services use stubs - integrate via Vercel AI Gateway
- ✅ 10 journey modules fully functional
- ✅ Refactored chat route activated (85% code reduction: 1410 → 200 lines)
- ✅ Type-safe throughout (8 type guards added)
- ✅ Multi-layer security (API + RLS + validation)
- ✅ Rate limiting applied to 4 critical endpoints

### What Works Now
- Core CRUD operations (campaigns, ads, locations)
- Meta connection flow
- Location targeting with include/exclude
- Publishing workflow (requires Meta connection)
- AI features (require Vercel AI Gateway integration for OpenAI)

See `MASTER_API_DOCUMENTATION.mdc` for complete endpoint details.
